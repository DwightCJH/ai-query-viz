from flask import Flask, request, jsonify
from dotenv import load_dotenv
import os
import json
import pandas as pd
from pandasai import Agent
from pandasai.llm.openai import OpenAI
from lida import Manager, TextGenerationConfig, llm
import io
import base64
import plotly.express as px
import plotly.graph_objects as go

load_dotenv()
app = Flask(__name__)

openai_api_key = os.getenv("OPENAI_API_KEY")
if not openai_api_key:
    raise ValueError("OpenAI API key not found in environment variables.")

try:
    lida_manager = Manager(text_gen=llm("openai", api_key=openai_api_key))
except Exception as e:
    print(f"Error initializing LIDA Manager: {e}")
    lida_manager = None

@app.route('/')
def home():
    return jsonify({"message": "Welcome to the Data Query Viz Backend"})

@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({"status": "Backend is running"})

@app.route('/api/query', methods=['POST'])
def query():
    try:
        payload = request.get_json()
        """
        payload = {
        "prompt": prompt,
        "data_json": data_json,
        "dataset_name": selected_display_name
        }
        """

        #validate required fields
        required_fields = ['prompt', 'data_json']
        if not payload or not all(field in payload for field in required_fields):
            missing = [field for field in required_fields if field not in payload]
            return jsonify({"error": f"Missing required fields: {', '.join(missing)}"}), 400
        
        # Extract data from payload
        prompt = payload['prompt']
        data_json = payload['data_json']
        dataset_name = payload.get('dataset_name', 'Unnamed Dataset') # Optional

        try:
            df = pd.read_json(io.StringIO(data_json))   
        except Exception as e:
            return jsonify({"error": f"Failed to parse data_json: {str(e)}"}), 400

        # Determine if prompt is asking for a visualization
        visualization_keywords = ["plot", "chart", "graph", "visualize", "visualization", "visualisation", 
                                "bar chart", "pie chart", "line chart", "scatter plot", "histogram", "show me"]
        
        # Check if prompt contains visualization keywords
        is_visualization_query = any(keyword.lower() in prompt.lower() for keyword in visualization_keywords)
        
        # Route query based on detected type
        if is_visualization_query and lida_manager:
            print(f"Received graph query for dataset '{dataset_name}': {prompt}")

            #summarize the data for LIDA
            #using cache for potentially faster subsequent calls on the same data summary
            textgen_config = TextGenerationConfig(n=1, temperature=0.2, use_cache=True)
            try:
                summary = lida_manager.summarize(
                    df,
                    summary_method="default",
                    textgen_config=textgen_config
                )
                print("LIDA summary generated.")
            except Exception as e:
                print(f"Error during LIDA summarization: {e}")
                return jsonify({"error": f"Failed to summarize data for LIDA: {str(e)}"}), 500  

            #generate visualisations with plotly      
            try:
                charts = lida_manager.visualize(summary=summary, goal=prompt, textgen_config=textgen_config, library="plotly")
                print(f"LIDA generated {len(charts)} chart candidates.")
            except Exception as e:
                print(f"Error during LIDA visualization generation: {e}")
                return jsonify({"error": f"Failed to generate visualization with LIDA: {str(e)}"}), 500

            if not charts:
                # If no charts were generated, create a fallback visualization
                print("No charts generated by LIDA, creating a fallback visualization")
                try:
                    # Create a fallback visualization based on dataset content
                    if 'price' in df.columns or any('price' in col.lower() for col in df.columns):
                        # Find price column
                        price_col = 'price' if 'price' in df.columns else next(col for col in df.columns if 'price' in col.lower())
                        
                        # Look for potential x-axis columns
                        potential_x_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['bedroom', 'bed', 'room', 'area', 'size'])]
                        x_col = potential_x_cols[0] if potential_x_cols else df.columns[0]
                        
                        # Create scatter plot or bar chart based on prompt
                        if any(keyword in prompt.lower() for keyword in ['scatter', 'relationship']):
                            fig = px.scatter(df, x=x_col, y=price_col, title=f'{price_col} vs {x_col}')
                        elif any(keyword in prompt.lower() for keyword in ['bar', 'column']):
                            fig = px.bar(df, x=x_col, y=price_col, title=f'{price_col} by {x_col}')
                        else:
                            fig = px.line(df, y=price_col, title=f'{price_col} Over Time')
                    else:
                        # Use first numeric column
                        numeric_cols = df.select_dtypes(include=['number']).columns
                        if len(numeric_cols) > 0:
                            y_col = numeric_cols[0]
                            # Try to find a sensible x column
                            x_cols = [col for col in df.columns if col != y_col]
                            x_col = x_cols[0] if x_cols else None
                            
                            if 'bar' in prompt.lower():
                                fig = px.bar(df, x=x_col, y=y_col, title=f'{y_col} Chart')
                            else:
                                fig = px.line(df, x=x_col, y=y_col, title=f'{y_col} Chart')
                        else:
                            return jsonify({
                                "response_type": "error",
                                "content": "Could not generate a visualization: No numeric columns found in the data"
                            }), 500
                    
                    plotly_json = fig.to_json()
                    print("Created fallback chart")
                    
                    return jsonify({
                        "response_type": "plot",
                        "content": plotly_json
                    }), 200
                except Exception as e:
                    print(f"Error creating fallback visualization: {e}")
                    return jsonify({
                        "response_type": "error",
                        "content": f"Could not generate a visualization: {str(e)}"
                    }), 500
            
            plotly_spec = charts[0].spec
            
            # Debug the structure of plotly_spec
            print(f"Plot type: {type(plotly_spec)}")
            
            try:
                # Check if plotly_spec is None before proceeding
                if plotly_spec is None:
                    raise ValueError("Plot specification is None")
                
                # Handle both dictionary and string cases
                if isinstance(plotly_spec, dict):
                    plotly_json = json.dumps(plotly_spec, default=str)
                else:
                    # Try to parse as JSON if it's already a string
                    json.loads(plotly_spec)  # Just to validate
                    plotly_json = plotly_spec
                
                # Additional validation
                fig_dict = json.loads(plotly_json)
                if not isinstance(fig_dict, dict) or not 'data' in fig_dict:
                    raise ValueError("Plot JSON does not contain valid Plotly figure data")
                
                print(f"Successfully validated plot JSON")
            except Exception as e:
                print(f"Error processing Plotly spec: {e}")
                
                # Fallback to a basic chart if there's an error
                if 'price' in df.columns:
                    fig = px.line(df, y='price', title='House Prices')
                    plotly_json = fig.to_json()
                    print("Created fallback price chart")
                elif any('price' in col.lower() for col in df.columns):
                    # Try to find a price-related column
                    price_col = next(col for col in df.columns if 'price' in col.lower())
                    fig = px.line(df, y=price_col, title=f'{price_col} Over Time')
                    plotly_json = fig.to_json()
                    print(f"Created fallback chart for {price_col}")
                else:
                    # Last resort: visualize the first numeric column
                    numeric_cols = df.select_dtypes(include=['number']).columns
                    if len(numeric_cols) > 0:
                        fig = px.line(df, y=numeric_cols[0], title=f'{numeric_cols[0]} Chart')
                        plotly_json = fig.to_json()
                        print(f"Created fallback chart for {numeric_cols[0]}")
                    else:
                        return jsonify({
                            "response_type": "error",
                            "content": f"Could not generate a valid visualization: {str(e)}"
                        }), 500
            
            # Return in the format expected by frontend
            return jsonify({
                "response_type": "plot",
                "content": plotly_json
            }), 200

        else:
            print(f"Received text query for dataset '{dataset_name}': {prompt}")
            try:
                llm_openai = OpenAI(api_token=openai_api_key)
                agent = Agent(df.copy(), config={"llm": llm_openai, "verbose": True, "enforce_privacy": True}) 

                # Process the query using PandasAI
                response = agent.chat(prompt)

                #check response type - PandasAI can return strings, numbers, DataFrames, etc.
                if isinstance(response, (pd.DataFrame, pd.Series)):
                    # Format as markdown for better display
                    markdown_table = response.to_markdown()
                    return jsonify({
                        "response_type": "text",
                        "content": markdown_table
                    }), 200
                elif isinstance(response, (int, float, bool)):
                    return jsonify({
                        "response_type": "text",
                        "content": str(response)
                    }), 200
                else:
                    return jsonify({
                        "response_type": "text", 
                        "content": str(response)
                    }), 200

            except Exception as e:
                print(f"Error during PandasAI processing: {e}")
                return jsonify({
                    "response_type": "error",
                    "content": f"Error processing text query: {str(e)}"
                }), 500

    except Exception as e:
        #general fallback error handling
        print(f"An unexpected error occurred: {e}")
        return jsonify({
            "response_type": "error",
            "content": f"An unexpected server error occurred: {str(e)}"
        }), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)